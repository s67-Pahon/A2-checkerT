int rows = 8;
int cols = 8;
int squaresize = 75;
int piecesize = 45;
boolean pieceSelected = false;
int selectedX = -1, selectedY = -1;

int[][] board = new int[rows][cols]; // 1 = red, 2 = black, 0 = empty
boolean[][] highlightMoves = new boolean[rows][cols]; // Tracks squares to highlight

void setup() {
  size(700, 600);
  initializeBoard();
}

void draw() {
  drawcheckerboard();
  drawpieces();
}

// Initialize the board with pieces in the starting positions
void initializeBoard() {
  for (int j = 0; j < rows; j++) {
    for (int i = 0; i < cols; i++) {
      if ((i + j) % 2 != 0) {
        if (j < 2) {
          board[i][j] = 1; // Red piece
        } else if (j > 5) {
          board[i][j] = 2; // Black piece
        }
      }
    }
  }
}

// Draw the checkerboard with highlighted available moves
void drawcheckerboard() {
  stroke(0);  // Set default stroke for the checkerboard squares (black border)
  strokeWeight(1);  // Standard thin border
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (highlightMoves[i][j]) {
        fill(100, 255, 100);  // Highlight valid moves (light green)
      } else if ((i + j) % 2 == 0) {
        fill(240);  // White
      } else {
        fill(255, 157, 94);  // Brown
      }
      rect(i * squaresize, j * squaresize, squaresize, squaresize);
    }
  }
}

// Draw the pieces on the board and highlight the selected piece
void drawpieces() {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (board[i][j] != 0) {
        // Check if this piece is the selected one
        if (pieceSelected && i == selectedX && j == selectedY) {
          stroke(0, 255, 0);  // Add a green border for the selected piece
          strokeWeight(4);  // Thicker border
        } else {
          stroke(0, 0, 0);  // Black border
          strokeWeight(1); // Thin border
        }

        // Draw the red or black piece
        if (board[i][j] == 1) {
          fill(255, 0, 0);  // Red piece
        } else if (board[i][j] == 2) {
          fill(0, 0, 0);  // Black piece
        }
        ellipse(i * squaresize + squaresize / 2, j * squaresize + squaresize / 2, piecesize, piecesize);
      }
    }
  }
  noStroke();  // Reset stroke for other drawings
}


// Handle mouse click to select and move pieces with taking functionality
void mousePressed() {
  int i = mouseX / squaresize;
  int j = mouseY / squaresize;

  // Ensure the click is within the bounds of the board
  if (i >= 0 && i < rows && j >= 0 && j < cols) {
    // If no piece is selected, check if a piece is clicked
    if (!pieceSelected && board[i][j] != 0) {
      pieceSelected = true;
      selectedX = i;
      selectedY = j;
      highlightValidMoves(i, j); // Highlight available moves for selected piece
    } 
    // If a piece is selected
    else if (pieceSelected) {
      // If the selected piece is clicked again, deselect it
      if (i == selectedX && j == selectedY) {
        pieceSelected = false;
        selectedX = -1;
        selectedY = -1;
        clearHighlights(); // Clear move highlights
      }
      // If a different square is clicked, check for valid move or take
      else if (board[i][j] == 0 && (isValidMove(selectedX, selectedY, i, j) || canTake(selectedX, selectedY, i, j))) { 
        if (canTake(selectedX, selectedY, i, j)) {
          removeTakenPiece(selectedX, selectedY, i, j);  // Remove the opponent's piece if it's a taking move
        }
        board[i][j] = board[selectedX][selectedY]; // Move the piece
        board[selectedX][selectedY] = 0;  // Empty the old spot
        pieceSelected = false;  // Deselect the piece after moving
        selectedX = -1;
        selectedY = -1;
        clearHighlights(); // Clear move highlights after move
      }
    }
  }
}

// Highlight valid moves for the selected piece
void highlightValidMoves(int startX, int startY) {
  clearHighlights(); // Clear any previous highlights

  // Loop through all possible moves on the board
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (board[i][j] == 0 && (isValidMove(startX, startY, i, j) || canTake(startX, startY, i, j))) {
        highlightMoves[i][j] = true; // Highlight this square as a valid move
      }
    }
  }
}

// Clear all highlighted moves
void clearHighlights() {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      highlightMoves[i][j] = false;
    }
  }
}

// Check if the move is valid (diagonal and adjacent)
boolean isValidMove(int startX, int startY, int endX, int endY) {
  int piece = board[startX][startY];
  int deltaX = abs(startX - endX);
  int deltaY = endY - startY;

  // Ensure the piece moves diagonally to an adjacent square (1 step)
  if (deltaX == 1 && abs(deltaY) == 1) {
    // Red pieces can only move downwards
    if (piece == 1 && deltaY == 1) {
      return true;
    }
    // Black pieces can only move upwards
    if (piece == 2 && deltaY == -1) {
      return true;
    }
  }
  return false; // Invalid move
}

// Check if the piece can take an opponent's piece
boolean canTake(int startX, int startY, int endX, int endY) {
  int piece = board[startX][startY];
  int deltaX = abs(startX - endX);
  int deltaY = endY - startY;

  // Ensure the piece jumps diagonally (2 steps)
  if (deltaX == 2 && abs(deltaY) == 2) {
    int middleX = (startX + endX) / 2;
    int middleY = (startY + endY) / 2;
    int middlePiece = board[middleX][middleY];

    // Red pieces can only take black pieces by moving downward
    if (piece == 1 && deltaY == 2 && middlePiece == 2) {
      return true;
    }
    // Black pieces can only take red pieces by moving upward
    if (piece == 2 && deltaY == -2 && middlePiece == 1) {
      return true;
    }
  }
  return false; // Invalid take
}

// Remove the piece that was jumped over
void removeTakenPiece(int startX, int startY, int endX, int endY) {
  int middleX = (startX + endX) / 2;
  int middleY = (startY + endY) / 2;
  board[middleX][middleY] = 0;  // Remove the opponent's piece
}
