int rows = 8;
int cols = 8;
int squaresize = 75;
int piecesize = 45;
boolean pieceSelected = false;
int selectedX = -1, selectedY = -1;

int[][] board = new int[rows][cols]; // 1 = red, 2 = black, 3 = red king, 4 = black king
boolean[][] highlightMoves = new boolean[rows][cols]; // Tracks squares to highlight

void setup() {
  size(700, 600);
  initializeBoard();
}

void draw() {
  drawcheckerboard();
  drawpieces();
}

// Initialize the board with pieces in the starting positions
void initializeBoard() {
  for (int j = 0; j < rows; j++) {
    for (int i = 0; i < cols; i++) {
      if ((i + j) % 2 != 0) {
        if (j < 2) {
          board[i][j] = 1; // Red piece
        } else if (j > 5) {
          board[i][j] = 2; // Black piece
        }
      }
    }
  }
}

// Draw the checkerboard with highlighted available moves
void drawcheckerboard() {
  stroke(0);  // Set default stroke for the checkerboard squares (black border)
  strokeWeight(1);  // Standard thin border
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (highlightMoves[i][j]) {
        fill(100, 255, 100);  // Highlight valid moves (light green)
      } else if ((i + j) % 2 == 0) {
        fill(240);  // White
      } else {
        fill(255, 157, 94);  // Brown
      }
      rect(i * squaresize, j * squaresize, squaresize, squaresize);
    }
  }
}

// Draw the pieces on the board and highlight the selected piece
void drawpieces() {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (board[i][j] != 0) {
        // Check if this piece is the selected one
        if (pieceSelected && i == selectedX && j == selectedY) {
          stroke(0, 255, 0);  // Add a green border for the selected piece
          strokeWeight(4);  // Thicker border
        } else {
          stroke(0, 0, 0);  // Black border
          strokeWeight(1); // Thin border
        }

        // Draw the piece (red, black, or king)
        if (board[i][j] == 1 || board[i][j] == 3) {
          fill(255, 0, 0);  // Red piece or red king
        } else if (board[i][j] == 2 || board[i][j] == 4) {
          fill(0, 0, 0);  // Black piece or black king
        }
        ellipse(i * squaresize + squaresize / 2, j * squaresize + squaresize / 2, piecesize, piecesize);

        // Add a smaller circle for king pieces
        if (board[i][j] == 3 || board[i][j] == 4) {
          fill(255, 255, 255);  // White crown for kings
          ellipse(i * squaresize + squaresize / 2, j * squaresize + squaresize / 2, piecesize / 2, piecesize / 2);
        }
      }
    }
  }
  noStroke();  // Reset stroke for other drawings
}

// Handle mouse click to select and move pieces with taking functionality
void mousePressed() {
  int i = mouseX / squaresize;
  int j = mouseY / squaresize;

  // Ensure the click is within the bounds of the board
  if (i >= 0 && i < rows && j >= 0 && j < cols) {
    // If no piece is selected, check if a piece is clicked
    if (!pieceSelected && board[i][j] != 0) {
      pieceSelected = true;
      selectedX = i;
      selectedY = j;
      highlightValidMoves(i, j); // Highlight available moves for selected piece
    } 
    // If a piece is selected
    else if (pieceSelected) {
      // If the selected piece is clicked again, deselect it
      if (i == selectedX && j == selectedY) {
        pieceSelected = false;
        selectedX = -1;
        selectedY = -1;
        clearHighlights(); // Clear move highlights
      }
      // If a different square is clicked, check for valid move or take
      else if (board[i][j] == 0 && (isValidMove(selectedX, selectedY, i, j) || canTake(selectedX, selectedY, i, j))) { 
        if (canTake(selectedX, selectedY, i, j)) {
          removeTakenPiece(selectedX, selectedY, i, j);  // Remove the opponent's piece if it's a taking move
        }
        board[i][j] = board[selectedX][selectedY]; // Move the piece
        board[selectedX][selectedY] = 0;  // Empty the old spot
        pieceSelected = false;  // Deselect the piece after moving
        selectedX = -1;
        selectedY = -1;
        clearHighlights(); // Clear move highlights after move
        checkKing(i, j);  // Check if the piece should be crowned king
      }
    }
  }
}

// Highlight valid moves for the selected piece
void highlightValidMoves(int startX, int startY) {
  clearHighlights(); // Clear any previous highlights

  // Loop through all possible moves on the board
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (board[i][j] == 0 && (isValidMove(startX, startY, i, j) || canTake(startX, startY, i, j))) {
        highlightMoves[i][j] = true; // Highlight this square as a valid move
      }
    }
  }
}

// Clear all highlighted moves
void clearHighlights() {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      highlightMoves[i][j] = false;
    }
  }
}

// Check if the move is valid (diagonal and adjacent)
boolean isValidMove(int startX, int startY, int endX, int endY) {
  int piece = board[startX][startY];
  int deltaX = abs(startX - endX);
  int deltaY = endY - startY;

  // Kings can move both ways; normal pieces can only move one way
  if (piece == 3 || piece == 4) {  // King piece can move forward or backward
    if (deltaX == 1 && abs(deltaY) == 1) {
      return true;
    }
  } else {  // Regular pieces can only move in one direction
    if (deltaX == 1 && abs(deltaY) == 1) {
      // Red pieces can only move downwards
      if (piece == 1 && deltaY == 1) {
        return true;
      }
      // Black pieces can only move upwards
      if (piece == 2 && deltaY == -1) {
        return true;
      }
    }
  }
  return false; // Invalid move
}

// Check if the piece can take an opponent's piece
boolean canTake(int startX, int startY, int endX, int endY) {
  int piece = board[startX][startY];
  int deltaX = abs(startX - endX);
  int deltaY = endY - startY;

  // Ensure the piece jumps diagonally (2 steps)
  if (deltaX == 2 && abs(deltaY) == 2) {
    int middleX = (startX + endX) / 2;
    int middleY = (startY + endY) / 2;
    int middlePiece = board[middleX][middleY];

    // Regular pieces and kings can take based on rules
    if (piece == 1 && deltaY == 2 && (middlePiece == 2 || middlePiece == 4)) {  // Red takes black
      return true;
    }
    if (piece == 2 && deltaY == -2 && (middlePiece == 1 || middlePiece == 3)) {  // Black takes red
      return true;
    }
    if (piece == 3 || piece == 4) {  // Kings can take both ways
      if (middlePiece == 1 || middlePiece == 2 || middlePiece == 3 || middlePiece == 4) {
        return true;
      }
    }
  }
  return false; // Invalid take
}

// Remove the piece that was jumped over
void removeTakenPiece(int startX, int startY, int endX, int endY) {
  int middleX = (startX + endX) / 2;
  int middleY = (startY + endY) / 2;
  board[middleX][middleY] = 0;  // Remove the opponent's piece
}

// Check if a piece has reached the opposite end to become a king
void checkKing(int i, int j) {
  if (j == 0 && board[i][j] == 2) {
    board[i][j] = 4;  // Black becomes a king
  } else if (j == rows - 1 && board[i][j] == 1) {
    board[i][j] = 3;  // Red becomes a king
  }
}
